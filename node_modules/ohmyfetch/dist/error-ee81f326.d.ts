declare type Fetch = typeof globalThis.fetch;
declare type RequestInfo = globalThis.RequestInfo;
declare type RequestInit = globalThis.RequestInit;
declare type Response = globalThis.Response;

interface ResponseMap {
    blob: Blob;
    text: string;
    arrayBuffer: ArrayBuffer;
}
declare type ResponseType = keyof ResponseMap | 'json';
declare type MappedType<R extends ResponseType, JsonType = any> = R extends keyof ResponseMap ? ResponseMap[R] : JsonType;

interface CreateFetchOptions {
    fetch: Fetch;
}
declare type FetchRequest = RequestInfo;
interface SearchParams {
    [key: string]: any;
}
interface FetchOptions<R extends ResponseType = ResponseType> extends Omit<RequestInit, 'body'> {
    baseURL?: string;
    body?: RequestInit['body'] | Record<string, any>;
    params?: SearchParams;
    parseResponse?: (responseText: string) => any;
    responseType?: R;
    response?: boolean;
    retry?: number | false;
}
interface FetchResponse<T> extends Response {
    data?: T;
}
interface $Fetch {
    <T = any, R extends ResponseType = 'json'>(request: FetchRequest, opts?: FetchOptions<R>): Promise<MappedType<R, T>>;
    raw<T = any, R extends ResponseType = 'json'>(request: FetchRequest, opts?: FetchOptions<R>): Promise<FetchResponse<MappedType<R, T>>>;
}
declare function setHeader(options: FetchOptions, _key: string, value: string): void;
declare function createFetch({ fetch }: CreateFetchOptions): $Fetch;

declare class FetchError<T = any> extends Error {
    name: 'FetchError';
    request?: FetchRequest;
    response?: FetchResponse<T>;
    data?: T;
}
declare function createFetchError<T = any>(request: FetchRequest, error?: Error, response?: FetchResponse<T>): FetchError<T>;

export { $Fetch as $, CreateFetchOptions as C, FetchRequest as F, SearchParams as S, FetchOptions as a, FetchResponse as b, createFetch as c, FetchError as d, createFetchError as e, setHeader as s };
